/*
 * Copyright 2025 Mitch Trachtenberg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package sample.camel.services;

import java.time.LocalTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.*;

import org.apache.camel.CamelContext;
import org.apache.camel.Route;
import org.apache.camel.api.management.ManagedCamelContext;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.scheduling.annotation.Scheduled;

import sample.camel.websocket.RouteStatsWebSocketHandler;
import com.google.gson.Gson;

// We use web services to send a message to any subscribing
// user interface with the routeId and its associated message counts.
// This gets sent to an already-open HTML page generated by Thymeleaf,
// which has a script onMessage handler that updates the appropriate
// fields of the row corresponding to the route which generated
// an update.

// Note that the AIs claim you should use micrometer values instead.
// This requires the next import and the private function at the bottom,
// but is not working in camel 4.10; exchangesCompleted shows how
// that function would be used in place of the managed route retrieval.
import io.micrometer.core.instrument.MeterRegistry;


@Service
public class RouteCountUpdateService {

    @Autowired
    private CamelContext camelContext;

    @Autowired
    private MeterRegistry meterRegistry;
    
    @Autowired
    RouteStatsWebSocketHandler webSocketHandler;

    public void pushStats(Route route) {
	ManagedCamelContext managed = 
	    camelContext.getCamelContextExtension().getContextPlugin(
				           ManagedCamelContext.class);

	String exchangesCompleted = String.valueOf(
		managed.getManagedRoute(route.getId()).getExchangesCompleted()
		//getCounter("camel.route.exchanges.completed",route.getId())
					          );
	
	String exchangesFailed = String.valueOf(
	     managed.getManagedRoute(route.getId()).getExchangesFailed()
				  );
	String exchangesInflight = String.valueOf(
	     managed.getManagedRoute(route.getId()).getExchangesInflight()
				  );
	Map<String,Object> update = new HashMap<>();
	update.put("routeId",route.getId());
	update.put("exchangesCompleted", exchangesCompleted);
	update.put("exchangesFailed", exchangesFailed);
	update.put("exchangesInflight", exchangesInflight);
	String json = new Gson().toJson(update);
	webSocketHandler.broadcast(json);
    }
    private double getCounter(String metricName, String routeId) {
	return meterRegistry
	    .find(metricName)
	    .tags("routeId", routeId)
	    .counter()
	    .count();
    }

}
